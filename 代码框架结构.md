在这里把框架搭出来，说明需要的函数名，输入输出内容，所需参数的类型等，方便最后写报告参考。

如有函数结构更新需要同步在这个文档里，并填写修改记录。

# 修改记录

- 2021/12/20 16:36 zzj：定义基本接口，比较粗略的框架。



# 图片处理

**imgUil.py**

已安装Pillow库（代码中为PIL）。

```python
def read_img(filepath: str) -> bytes:
    """输入图片路径，读取图片，返回对应字节流"""
    pass  # pass为占位符，实现时删掉该行

def save_img(img: bytes, filepath: str):
    """输入图片字节流和保存路径，把字节流转化为图片并保存（可用PIL库实现）"""
    pass

def show_img(img: bytes):
    """方便debug，根据字节流直接转化为图片并显示（可用PIL库实现）"""
    pass
```



# 加密解密

使用AES、CBC进行加密。

可参考https://zhuanlan.zhihu.com/p/184968023，https://www.cnblogs.com/xuchunlin/p/11421795.html

已安装Crypto库 (windows下为pycryptodome)

自行添加所需函数、参数，并更新本文档。

**注：**第一次iv和密钥key随机生成，然后写入到本地文件固定，以后加密和解密时都从文件里读取iv和key。

类实现：

**aesutil.py**

```python
class AESUtil:
    """加密解密相关操作"""

    def __init__(self, config: str = AES_CONFIG_PATH):
        """
        如果config不为空则从配置文件初始化self.iv和self.key，
        否则随机初始化self.iv和self.key。

        :param config: 配置文件路径字符串
        """
        # 参考代码
        if config:
            self.iv, self.key = self.read_config(config)
        else:
            self.iv, self.key = self.rand_init()

    def save_config(self, config: str = AES_CONFIG_PATH):
        """
        保存iv和key到配置文件中，可以考虑构建字典然后JSON.dump，则配置文件后缀名为.json

        :param config: 配置文件路径字符串
        """
        pass  # pass为占位符，实现时删掉该行

    def read_config(self, config: str = AES_CONFIG_PATH) -> Tuple[str, str]:
        """
        从配置文件中读取iv和key，可以考虑用JSON.load读取字典，并返回(iv, key)二元组

        :param config: 配置文件路径字符串
        """
        pass

    def rand_init(self) -> Tuple[str, str]:
        """随机初始化iv和key，并返回(iv, key)二元组"""
        pass

    def encrypt(self, m: bytes) -> bytes:
        """对明文字节流m加密，返回密文字节流"""
        pass

    def decrypt(self, c: bytes) -> bytes:
        """对密文字节流c解密，返回明文字节流"""
        pass
```

# 信息嵌入、提取

还未看论文，暂定。

**注：**第一次密钥key随机生成，然后写入到本地文件固定，以后加密和解密时都从文件里读取key。

**dataEmbedder.py**

```python
class DataEmbedder:
    """信息嵌入提取相关操作"""

    def __init__(self, config: str = EMBED_CONFIG_PATH, aesconfig: str = AES_CONFIG_PATH):
        """
        如果config不为空则从配置文件初始化self.key，
        否则随机初始化self.key。
        如果aesconfig不为空，初始化AESUtil，用于完美解密图片。

        :param config: 配置文件路径字符串
        :param aesconfig: 加解密相关配置文件路径字符串
        """
        # 参考代码
        if config:
            self.key = self.read_config(config)
        else:
            self.key = self.rand_init()

        if aesconfig:
            self.aes = AESUtil(aesconfig)
        else:
            self.aes = None

    def save_config(self, config: str = EMBED_CONFIG_PATH):
        """
        保存key到配置文件中

        :param config: 配置文件路径字符串
        """
        pass  # pass为占位符，实现时删掉该行

    def read_config(self, config: str = EMBED_CONFIG_PATH) -> str:
        """
        从配置文件中读取key，并返回key

        :param config: 配置文件路径字符串
        """
        pass

    def rand_init(self) -> str:
        """随机初始化key，并返回key"""
        pass

    def embed(self, data: bytes, img: bytes) -> bytes:
        """把字节流data嵌入到密文字节流img中，返回嵌入后的字节流"""
        pass

    def extract(self, img: bytes) -> bytes:
        """从字节流img中提取信息，返回提取出的信息字节流"""
        pass

    def perfect_decrypt(self):
        """
        如果同时拥有加密密钥和嵌入密钥，可以无损解密原始图片。
        需要调用AESUtil相关功能。
        我认为应该由信息嵌入器进行处理，因为该功能只有信息嵌入者知道。
        
        如果可以先提取再解密实现的话，就不需要这个函数
        """
        if not self.aes: return
        pass
```



# GUI

分不同角色做三个不同的GUI

**guimain.py**

**guilayout.py**



# Main

命令行入口，用于测试。

**main.py**



# 各种常量

**consts.py：**

```python
# 各种常量，方便写GUI和Main时直接使用
AES_CONFIG_PATH = "aesConf.json"  # 加密相关配置文件默认存储路径
EMBED_CONFIG_PATH = "embedConf.json"  # 信息嵌入相关配置文件默认存储路径
```



# 附录

字符串转字节流（即字符串编码）：`str.encode('utf8')`

字节流转字符串（即字符串解码）：`bytes.decode('utf8')`
